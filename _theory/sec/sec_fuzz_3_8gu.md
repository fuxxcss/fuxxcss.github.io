---
title: "动态漏洞挖掘：八股文 （Part 3/3）"
excerpt: '模糊测试的八股文'

collection: theory
category: sec
permalink: /theory/fuzz-8gu
tags: 
  - fuzz

layout: single
read_time: true
author_profile: false
comments: true
share: true
related: true
---

![](../../images/theory/8gu.png)

**1.QEMU模式、源码模式的区别？**

对比一下qemu模式fuzz和源码模式fuzz，说说qemu模式的动态插桩怎么实现的，有什么优缺点？

**2.普通程序、数据库模糊测试的区别？**

fuzz普通程序和数据库有哪些不同点？
怎么给AFL做适配去fuzz数据库？

**3.AFL++、AFL的区别？**

看你的博客有用过afl++去挖漏洞，说说afl++和afl有哪些不同？你觉得afl++有哪些策略对你来说很有用？

**4.AFL组成模块的工作流程？**

有哪些模块，每个模块的流程？ afl-fuzz为什么速度很快？
从选取目标开始插桩

**5.AFL的插桩原理？**

**6.如何选择模糊测试的测试点？**

感觉类似于fuzz单个API函数吧

**7.针对一个开源项目Redis，如何动态挖掘？**

规定挖掘Redis漏洞的范围，核心模块：
- 服务接口：如Redis使用RESP协议，测试该协议。
- 缓存命令：测试命令的执行路径。
- 多路复用：主要测试竞态条件。
- 主从复制：测试主从节点的交互。
- 持久化：测试持久化文件格式的解析。

**追问1：如何保证你的测试覆盖了缓存中间件的核心攻击面（如主从复制、持久化等）？**

**“依赖图”和“Token模型”具体指什么？是自己定义的吗？请详细解释它们的结构和是如何构建的？**

- Token模型：保留语法正确，将命令分解成Token，变异键值。
- 依赖图：保留语义正确，描述了命令之间的依赖关系，探索更复杂的状态交互逻辑。

**追问1：与标准的AFL++相比，你的改进策略带来了多少效率提升？你是如何量化评估这个效果的？**

- 代码覆盖率。
- 语法正确、语义正确的测试用例数量。

**如何实现的服务端覆盖率统计？**

- 对服务端代码进行插桩，插入的代码会将执行到的边信息写入一块共享内存。

**追问1：共享内存机制是如何搭建起来的？如何解决跨进程、跨环境的通信问题？**

- 被插桩的中间件进程在启动时，会分配一块共享内存，覆盖率数据直接写入其中。外部的Fuzzer进程则直接读取这块共享内存来获取反馈，指导下一轮的变异。

**追问2：引导Fuzzer的覆盖率反馈是边缘覆盖率（edge coverage）还是块覆盖率（block coverage）？你如何看待这两种方式的优劣？**

- 边缘覆盖率（Edge Coverage），它记录了代码块之间的转移关系，比单纯的块覆盖率（Block Coverage）包含了更多的上下文信息，对Fuzzer的引导效果更好。

**工具目前支持Redis和Memcached，如果现在需要你快速接入一种新的缓存中间件，例如KeyDB或Dragonfly，工具架构需要做哪些调整？如何设计以最小化适配成本？**

- 模糊测试：插桩、编写客户端代码（执行、收集依赖关系、启动、关闭）。

**如何为“缓冲区溢出”、“整型溢出”这类漏洞设计初始测试用例？说明构造Payload的思路？**

- 缓冲区溢出：核心是突破长度限制。例如，构造一个远超proto-max-bulk-len配置值的超长字符串作为SET命令的值；或者构造一个包含海量元素的数组请求。
- 整型溢出：核心是触发数值回绕。例如，传入一个-1或0xFFFFFFFF作为大小或长度参数，使其在后续的计算中（如malloc(size * sizeof(char))）发生溢出，导致分配过小的缓冲区。

**在测试过程中，如何避免Fuzzer导致中间件崩溃后无法继续测试？你的工具是否实现了自动崩溃分类、去重和恢复的机制？**

- 自动恢复：Fuzzer监控进程会检测目标中间件是否崩溃。一旦崩溃，监控进程会立即重启中间件服务，确保Fuzzing过程能持续进行。
- 自动去重：基于ASAN，给出漏洞在源码/二进制码中的位置，基于此`位置哈希`去重。
- 自动分类：基于ASAN，初步分类为heap-buffer-overflow、stack-overflow、integer-overflow等类型。

**当Fuzzer发现一个复杂的崩溃时，你通常使用什么工具链和方法来分析根本原因？请描述你的调试流程。**

- 查看ASAN的崩溃报告。
- 定位到代码位置上，对照触发崩溃的测试用例，分析根本原因。